# Рекомендации по архитектуре бэкенда Perf Assist на Go

## 1. Где располагать бэкенд

С учётом текущего репозитория `perf-assist` (монорепо с фронтендом, дизайн‑проектом и продуктовой спецификацией) оптимальная стратегия:

**Бэкенд на Go лучше вынести в отдельный сервис/репозиторий**, а не встраивать внутрь текущего фронтенд‑репо.

Причины:

- Текущий репозиторий явно сфокусирован на **фронтенде и продуктовой/LLM‑логике**, а не на серверной части.
- Бэкенд на Go потребует свою инфраструктуру: `go.mod`, CI/CD, деплой, миграции БД, возможно, отдельный runtime/хостинг.
- Разделение по bounded context: фронт — интерфейс и UX, бэкенд — API, хранение данных, интеграции.

## 2. Как держать связь контекста модели и продукта между проектами

Источник правды по модели данных и LLM‑контексту уже есть в:

- [`product/02-data-and-llm-design.md`](product/02-data-and-llm-design.md:1)
- [`product/03-architecture-and-prompts.md`](product/03-architecture-and-prompts.md:1)

Эти файлы можно считать **общей спецификацией** для фронта и бэкенда.

Практически:

- Можно оставить их в текущем репозитории как есть, но:
  - В Go‑репозитории завести ссылку в `README.md` на этот репо и конкретные файлы `product/*`.
  - В описании API (например, в [`docs/api.md`](docs/api.md:1) или [`docs/openapi.yaml`](docs/openapi.yaml:1)) явно ссылаться на разделы продуктовой спецификации.
- Для строгой синхронизации схемы данных:
  - Описать доменную модель и контракты API в **OpenAPI/Swagger** и генерировать:
    - Go‑модели и хендлеры в бэкенде.
    - TypeScript‑клиент/типы в фронтенде.
  - Либо использовать **JSON Schema** как единый источник правды для структур данных (events, tasks, metrics и т.п.).

## 3. Рекомендуемая структура бэкенд‑проекта на Go

Отдельный репозиторий, например `perf-assist-backend`:

- [`cmd/api/main.go`](cmd/api/main.go:1) — точка входа HTTP‑сервера.
- [`internal/http`](internal/http:1) — хендлеры, роутинг.
- [`internal/core`](internal/core:1) — доменная логика (tasks, sessions, metrics, suggestions).
- [`internal/store`](internal/store:1) — работа с БД (PostgreSQL/SQLite).
- [`internal/llmcontext`](internal/llmcontext/context.go:1) — сборка контекста для LLM.
- [`migrations`](migrations:1) — SQL‑миграции.
- [`docs/openapi.yaml`](docs/openapi.yaml:1) — контракт API.

В текущем фронтенд‑репо (или любом другом фронтенде):

- [`src/app/api/client.ts`](src/app/api/client.ts:1) — тонкий клиент к Go‑бэкенду, сгенерированный из OpenAPI или написанный вручную.
- Конфиг окружения (`.env`, `VITE_API_BASE_URL`) для указания URL бэкенда.

## 4. Когда можно положить Go‑бэкенд прямо в этот репозиторий

Если цель — **быстрый прототип** без сложного деплоя, можно создать папку [`backend/`](backend/main.go:1) в этом же репо:

- [`backend/go.mod`](backend/go.mod:1)
- [`backend/cmd/api/main.go`](backend/cmd/api/main.go:1)
- [`backend/internal/http`](backend/internal/http:1)
- [`backend/internal/core`](backend/internal/core:1)
- [`backend/internal/store`](backend/internal/store:1)
- [`backend/internal/llmcontext`](backend/internal/llmcontext/context.go:1)
- [`backend/migrations`](backend/migrations:1)

Даже в этом случае лучше логически отделить фронт и бэк (разные директории, разные пайплайны).

## 5. Связь LLM‑контекста между проектами

В [`product/03-architecture-and-prompts.md`](product/03-architecture-and-prompts.md:1) стоит явно зафиксировать:

- Какие именно сущности и поля нужны бэкенду для формирования промптов.
- Формат событий/логов, которые бэкенд будет хранить и отдавать фронту/LLM.

В Go‑бэкенде завести пакет [`internal/llmcontext`](internal/llmcontext/context.go:1), который:

- Собирает данные из БД в структуры, соответствующие описанию в [`product/02-data-and-llm-design.md`](product/02-data-and-llm-design.md:1).
- Формирует payload для LLM (через HTTP к внешнему LLM‑сервису или через ваш оркестратор).

Во фронтенде использовать только **стабильные API‑контракты**, не завязываясь на внутреннюю структуру промптов.

## 6. Итог

Архитектурно чище и масштабируемее — держать Go‑бэкенд как отдельный сервис (отдельный репозиторий или хотя бы отдельный корневой модуль `backend/`), а связь контекста модели обеспечивать через:

- Общую продуктовую спецификацию (`product/*`).
- Формализованный контракт (OpenAPI/JSON Schema), который синхронизирует фронт и бэк и отражает модель данных ассистента.

Этот файл можно положить в корень нового бэкенд‑проекта и использовать как архитектурный ориентир при генерации кода и проектировании модели данных.